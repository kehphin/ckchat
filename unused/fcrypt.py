#!/usr/bin/env python 

""" 
Yang Yang
CS4740
PS2: Application of Cryptography

A python application that encrypts and decrypts a text file.

"""

import sys 
import random
import os
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.backends.interfaces import RSABackend
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.ciphers import Cipher
from cryptography.hazmat.primitives.ciphers import algorithms
from cryptography.hazmat.primitives.ciphers import modes
from cryptography.hazmat.primitives.asymmetric import padding

# Encrypts the contents in inputFile and outputs the cipher to cipherFile
def encrypt(destPub, sendPriv, inputFile, cipherFile):
  hashLength = 16 # 16-byte hash for AES-CBC encryption
  private_key_send = None
  public_key_dest = None
  inputText = None

  # Load destination public key, sender private key, input text
  with open(destPub, "rb") as key_file:
    public_key_dest = serialization.load_pem_public_key(key_file.read(), backend=default_backend())
  with open(sendPriv, "rb") as key_file:
    private_key_send = serialization.load_pem_private_key(key_file.read(), password=None, backend=default_backend())
  with open(inputFile, "rb") as key_file:
    inputText = key_file.read()

  # Generate random hashes used for AES-CBC symmetric encryption of the message
  randomHash = os.urandom(hashLength)
  iv = os.urandom(hashLength)

  # Encrypt the message using 128-bit AES encryption with CBC, adding padding to ensure
  # that the message length is a multiple of the iv length.
  cipher = Cipher(algorithms.AES(randomHash), modes.CBC(iv), backend=default_backend())
  encryptor = cipher.encryptor()
  encryptedMessage = encryptor.update(pad(inputText, hashLength)) + encryptor.finalize()

  # Join the 128-bit symmetric key with the iv from CBC and encrypt using RSA and OAEP padding
  # generated by SHA1
  encryptedKeys = public_key_dest.encrypt(
    randomHash + iv,
    padding.OAEP(
        mgf=padding.MGF1(algorithm=hashes.SHA1()),
        algorithm=hashes.SHA1(),
        label=None
    )
  )

  # Join encrypted keys and message together
  encryptedOutput = encryptedKeys + encryptedMessage

  # Sign the message using RSA and SHA256
  signer = private_key_send.signer(
    padding.PSS(
        mgf=padding.MGF1(hashes.SHA256()),
        salt_length=padding.PSS.MAX_LENGTH
    ),
    hashes.SHA256()
  )
  signer.update(encryptedOutput)
  signature = signer.finalize()

  # Join the signature with the encrypted text
  signedEncryptedOutput = signature + encryptedOutput

  # Write to specified output file
  f = open(cipherFile, 'w+')
  f.write(signedEncryptedOutput)

# Decrypts the contents in cipherFile and outputs the cipher to outputFile
def decrypt(destPriv, sendPub, cipherFile, outputFile):
  private_key_dest = None
  public_key_send = None
  cipherText = None

  # Load destination private key, sender public key, and cipher text
  with open(destPriv, "rb") as key_file:
    private_key_dest = serialization.load_pem_private_key(key_file.read(), password=None, backend=default_backend())
  with open(sendPub, "rb") as key_file:
    public_key_send = serialization.load_pem_public_key(key_file.read(), backend=default_backend())
  with open(cipherFile, "rb") as key_file:
    cipherText = key_file.read()

  # Split the encrypted message into the signature portion, keys portion, and the messages portion
  signature = cipherText[:256]
  encryptedSection = cipherText[256:]
  encryptedMessageKeys = encryptedSection[:256]
  encryptedMessage = encryptedSection[256:]

  # Verify using RSA and SHA256 that the sender is legitimate
  verifier = public_key_send.verifier(
      signature,
      padding.PSS(
          mgf=padding.MGF1(hashes.SHA256()),
          salt_length=padding.PSS.MAX_LENGTH
      ),
      hashes.SHA256()
  )
  verifier.update(encryptedSection)
  verifier.verify()

  # Decrypt the RSA-encrypted keys
  decryptedKeys = private_key_dest.decrypt(
    encryptedMessageKeys,
    padding.OAEP(
        mgf=padding.MGF1(algorithm=hashes.SHA1()),
        algorithm=hashes.SHA1(),
        label=None
    )
  )

  # Split the keys string into the hash and the iv used to decode the symmetrical AES-CBC cipher
  randomHash = decryptedKeys[:16]
  iv = decryptedKeys[16:]

  # Decode the message using AES-CBC
  cipher = Cipher(algorithms.AES(randomHash), modes.CBC(iv), backend=default_backend())
  decryptor = cipher.decryptor()
  text = decryptor.update(encryptedMessage) + decryptor.finalize()

  # Unpad the text
  finalText = unpad(text)

  # Write to specified output file
  f = open(outputFile, 'w+')
  f.write(finalText)

# Pads text to the next multiple of the hashLength.
# Adds the unicode character of the padSize as the padding characters
def pad(inputText, hashLength):
  padSize = hashLength - len(inputText) % hashLength
  paddedBits = padSize * chr(padSize)
  return inputText + paddedBits

# Removes the padding of a padded text.
# Gets the unicode value of the padded character, which is also
# the length of padding, and uses it to trim the string
def unpad(inputText):
  unicodeValue = ord(inputText[-1])
  return inputText[0:-unicodeValue]

# Read user input, handle exceptions for user input error, and encrypt/decrypt accordingly
mode = sys.argv[1]
if mode == '-e':
  if len(sys.argv) != 6:
    print("Invalid number of arguments. Please check your input.")
  else:
    encrypt(destPub=sys.argv[2], sendPriv=sys.argv[3], inputFile=sys.argv[4], cipherFile=sys.argv[5])
elif mode == '-d':
  if len(sys.argv) != 6:
    print("Invalid number of arguments. Please check your input.")
  else:
    decrypt(destPriv=sys.argv[2], sendPub=sys.argv[3], cipherFile=sys.argv[4], outputFile=sys.argv[5])
else:
  print("fcrypt must be ran with `-e` for encrypt or `-d` for decrypt")
